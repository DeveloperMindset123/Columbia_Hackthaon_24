"use strict";
/**
 * @ignore
 */ /** */
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.createAqiFromBreakpoints = exports.round = void 0;
var debug_1 = __importDefault(require("debug"));
var l = (0, debug_1["default"])('shootismoke:convert');
/**
 * Round a number to closest 10^-{decimal}
 *
 * @param n - The float number to round
 * @param decimal - The number of decimals after the .
 */
function round(n, decimals) {
    if (decimals === void 0) { decimals = 0; }
    return Math.round(Math.pow(10, decimals) * n) / Math.pow(10, decimals);
}
exports.round = round;
/**
 * From the breakpoints, we can derive the range (i.e. [min,max]) values of the
 * AQI.
 *
 * @param breakpoints - The breakpoints to calculate the range from
 */
function getRange(breakpoints) {
    return [breakpoints[0][0], breakpoints[breakpoints.length - 1][1]];
}
/**
 * Convert an AQI to ugm3 concentration using breakpoints
 *
 * @param value - AQI value to convert
 * @param breakpoints - Breakpoints defining the AQI
 */
function toUgm3(aqiPiecewise, ugm3Piecewise, value) {
    // Find the segment in which the `aqi` is
    var segment = aqiPiecewise.findIndex(function (_a) {
        var _b = __read(_a, 2), aqiLow = _b[0], aqiHigh = _b[1];
        return aqiLow <= value && value <= aqiHigh;
    });
    if (segment === -1) {
        // For PM2.5 greater than 500, AQI is not officially defined, but since
        // such levels have been occurring throughout China in recent years, one of
        // two conventions is used. Either the AQI is defined as equal to PM2.5 (in
        // micrograms per cubic meter) or the AQI is simply set at 500.
        // We take the 1st convention here.
        // We also do the same for other pollutants
        return value;
    }
    var _a = __read(aqiPiecewise[segment], 2), aqiLow = _a[0], aqiHigh = _a[1];
    var _b = __read(ugm3Piecewise[segment], 2), ugm3Low = _b[0], ugm3High = _b[1];
    // Round to closest 0.1
    return round(((value - aqiLow) / (aqiHigh - aqiLow)) * (ugm3High - ugm3Low) +
        ugm3Low, 1);
}
/**
 * Convert ugm3 concentration to AQI using breakpoints
 *
 * @param ugm3 - The ugm3 value to convert
 * @param breakpoints - Breakpoints defining the AQI
 */
function fromUgm3(aqiPiecewise, ugm3Piecewise, ugm3) {
    // Find the segment in which the `aqi` is
    var segment = ugm3Piecewise.findIndex(function (_a) {
        var _b = __read(_a, 2), ugm3Low = _b[0], ugm3High = _b[1];
        return ugm3Low <= ugm3 && ugm3 <= ugm3High;
    });
    if (segment === -1) {
        // For PM2.5 greater than 500, AQI is not officially defined, but since
        // such levels have been occurring throughout China in recent years, one of
        // two conventions is used. Either the AQI is defined as equal to PM2.5 (in
        // micrograms per cubic meter) or the AQI is simply set at 500.
        // We take the 1st convention here.
        // We also do the same for other pollutants
        return ugm3;
    }
    var _a = __read(aqiPiecewise[segment], 2), aqiLow = _a[0], aqiHigh = _a[1];
    var _b = __read(ugm3Piecewise[segment], 2), ugm3Low = _b[0], ugm3High = _b[1];
    // Round to closest integer
    return round(((aqiHigh - aqiLow) / (ugm3High - ugm3Low)) * (ugm3 - ugm3Low) + aqiLow);
}
function assertTracked(aqiCode, pollutant, breakpoints) {
    if (!breakpoints.aqi) {
        l("".concat(aqiCode, " does not have AQI breakpoints"));
        throw new Error("".concat(aqiCode, " does not have AQI breakpoints"));
    }
    if (!breakpoints[pollutant]) {
        l("".concat(aqiCode, " does not apply to pollutant ").concat(pollutant));
        throw new Error("".concat(aqiCode, " does not apply to pollutant ").concat(pollutant));
    }
}
/**
 * Create an AQI from its breakpoints
 *
 * @param aqiCode - The code of the AQI
 * @param breakpoints - The breakpoints defining the AQI
 */
function createAqiFromBreakpoints(aqiCode, breakpoints) {
    return {
        pollutants: Object.keys(breakpoints),
        fromUgm3: function (pollutant, ugm3) {
            assertTracked(aqiCode, pollutant, breakpoints);
            return fromUgm3(breakpoints.aqi, breakpoints[pollutant], ugm3);
        },
        range: getRange(breakpoints.aqi),
        toUgm3: function (pollutant, value) {
            assertTracked(aqiCode, pollutant, breakpoints);
            return toUgm3(breakpoints.aqi, breakpoints[pollutant], value);
        }
    };
}
exports.createAqiFromBreakpoints = createAqiFromBreakpoints;
