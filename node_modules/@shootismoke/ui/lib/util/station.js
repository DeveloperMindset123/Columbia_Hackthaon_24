"use strict";
// Sh**t! I Smoke
// Copyright (C) 2018-2021  Marcelo S. Coelho, Amaury M.
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.isStationTooFar = exports.distanceToStation = exports.getCorrectLatLng = exports.MAX_DISTANCE_TO_STATION = exports.capitalize = void 0;
// Sh**t! I Smoke is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// Sh**t! I Smoke is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with Sh**t! I Smoke.  If not, see <http://www.gnu.org/licenses/>.
var dataproviders_1 = require("@shootismoke/dataproviders");
var haversine_1 = __importDefault(require("haversine"));
/**
 * Capitalize a string.
 *
 * @param s - The string to capitalize
 */
function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}
exports.capitalize = capitalize;
/**
 * Above this distance (km), we consider the station too far from the user
 */
exports.MAX_DISTANCE_TO_STATION = dataproviders_1.ACCURATE_RADIUS / 1000;
/**
 * Station given by the AQICN API is fucked up. Sometimes it's [lat, lng],
 * sometimes it's [lng, lat].
 * We check here with the user's real currentLocation coordinates, and take the
 * "closest" one.
 *
 * @param currentLocation - An object containing {latitude, longitude}
 * representing the user's current location.
 * @param station - An object containing {latitude, longitude} representing
 * the station's location.
 */
function getCorrectLatLng(currentLocation, station) {
    var d1 = Math.abs(currentLocation.latitude - station.latitude) +
        Math.abs(currentLocation.longitude - station.longitude);
    var d2 = Math.abs(currentLocation.latitude - station.longitude) +
        Math.abs(currentLocation.longitude - station.latitude);
    if (d1 < d2)
        return station;
    return __assign(__assign({}, station), { latitude: station.longitude, longitude: station.latitude });
}
exports.getCorrectLatLng = getCorrectLatLng;
/**
 * Get distance from current location to station.
 *
 * @param currentLocation - The current location of the user.
 * @param api - The api object returned by remote data.
 * @param unit - The unit of measure returned.
 */
function distanceToStation(currentLocation, pm25Measurement, unit) {
    if (unit === void 0) { unit = 'km'; }
    // This case should be very rare, only happens on OpenAQ that sometimes,
    // the `coordinates` field isn't returned. This field is actually optional
    // in the OpenAQ format.
    // FIXME Return something better than 0?
    if (!pm25Measurement.coordinates) {
        return 0;
    }
    return Math.round((0, haversine_1["default"])(currentLocation, getCorrectLatLng(currentLocation, pm25Measurement.coordinates), { unit: unit }));
}
exports.distanceToStation = distanceToStation;
/**
 * Returns true if the station is at more than {@link MAX_DISTANCE_TO_STATION}
 * kilometers away from the current location.
 *
 * @param currentLocation - The current location of the user.
 * @param api - The api object returned by remote data.
 */
function isStationTooFar(currentLocation, pm25Measurement) {
    return (distanceToStation(currentLocation, pm25Measurement) >
        exports.MAX_DISTANCE_TO_STATION);
}
exports.isStationTooFar = isStationTooFar;
