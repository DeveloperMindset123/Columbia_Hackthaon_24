"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.normalize = exports.sanitizeCountry = void 0;
var convert_1 = require("@shootismoke/convert");
var date_fns_tz_1 = require("date-fns-tz");
var util_1 = require("../../util");
var sanitized_json_1 = __importDefault(require("./sanitized.json"));
/**
 * Sanitize the country we get here from aqicn. For example, for China, the
 * string after 'https://aqicn.org/city/' is not 'china', but directly the
 * Chinese privince, e.g. 'jiangsu'. In this case, we map directly to China.
 * See sanitized.json for some other sanitazations, these are empirical, so
 * we add them as we discover them.
 *
 * FIXME This is hacky.
 */
function sanitizeCountry(input) {
    if (sanitized_json_1["default"][input.toLowerCase()]) {
        return sanitized_json_1["default"][input.toLowerCase()];
    }
    return input;
}
exports.sanitizeCountry = sanitizeCountry;
/**
 * Normalize aqicn byGps data. Throws an error if the data cannot be normalized.
 *
 * @param data - The data to normalize
 */
function normalize(data) {
    var stationId = "aqicn|".concat(data.idx);
    // Sometimes we don't get geo
    if (!data.city.geo) {
        throw (0, util_1.providerError)('aqicn', "Cannot normalize station ".concat(stationId, ", no city: ").concat(JSON.stringify(data)));
    }
    // Since AqiCN uses useEpa as AQI for the pollutants, we can only
    // normalize data for those pollutants
    var pollutants = Object.entries(data.iaqi || {}).filter(function (_a) {
        var _b = __read(_a, 1), pol = _b[0];
        return convert_1.usaEpa.pollutants.includes(pol);
    });
    if (!pollutants.length) {
        throw (0, util_1.providerError)('aqicn', "Cannot normalize station ".concat(stationId, ", no pollutants currently tracked: ").concat(JSON.stringify(data)));
    }
    // We now need to get the country from AQICN response. The only place I found
    // is city.url...
    // Example: https://aqicn.org/city/france/lorraine/thionville-nord/garche/
    var AQICN_DOMAIN = 'aqicn.org/city/';
    if (!data.city.url || !data.city.url.includes(AQICN_DOMAIN)) {
        throw (0, util_1.providerError)('aqicn', "Cannot extract country, got city.url: ".concat(data.city.url));
    }
    var countryRaw = sanitizeCountry(data.city.url.split(AQICN_DOMAIN)[1].split('/')[0]);
    // Get the timezoned date
    var utc = data.time.iso
        ? new Date(data.time.iso).toISOString()
        : new Date(+data.time.v * 1000).toISOString(); // FIXME Not sure this works, but iso field being empty is quite rare.
    var local = (0, date_fns_tz_1.format)((0, date_fns_tz_1.utcToZonedTime)(utc, data.time.tz || 'Z'), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");
    var countryCode = (0, util_1.getCountryCode)(countryRaw);
    if (!countryCode) {
        throw (0, util_1.providerError)('aqicn', "Cannot get code from country ".concat(countryRaw));
    }
    return pollutants.map(function (_a) {
        var _b = __read(_a, 2), pol = _b[0], v = _b[1].v;
        var pollutant = pol;
        if (!data.city.geo) {
            throw new Error('We returned TE.left if data.city.geo was not defined. qed.');
        }
        return {
            attribution: data.attributions,
            averagingPeriod: {
                unit: 'day',
                value: 1
            },
            city: data.city.name,
            coordinates: {
                latitude: +data.city.geo[0],
                longitude: +data.city.geo[1]
            },
            country: countryCode,
            date: { local: local, utc: utc },
            location: stationId,
            isMobile: false,
            parameter: pollutant,
            sourceName: 'aqicn',
            entity: 'other',
            value: (0, convert_1.convert)(pollutant, 'usaEpa', convert_1.ugm3, v),
            unit: (0, convert_1.getPollutantMeta)(pollutant).preferredUnit
        };
    });
}
exports.normalize = normalize;
